'''
Simple ASCII Map generator. Using part of the Prim's algorithm implementation from https://gist.github.com/gmalmquist/.
'''
import random


class Map(object):
    '''
    :var
        EMPTY = variable contains space char for board build
        WALL = variable contains hash char for board build
        generated_map = variable contains generated dict map
        size_map = the height of the board
        size_map_od = other dimension, width of the board generated by size_map * 1.6 to make square board
        generated_map_string = variable keeps generated_map converted to string
    '''

    EMPTY = ' '
    WALL = '#'
    generated_map = {}
    size_map = 0
    size_map_od = 0  # additional var for other dimension
    generated_map_string = ""

    def neighbor_cell(self, cell):
        '''
        Checking and generating next cell's neighbor  of current cell
        :param cell: cell coordinates
        :return: generated coordinates of the cell's neighbors
        '''
        i, j = cell
        for (y, x) in ((1, 0), (0, 1), (-1, 0), (0, -1)):
            yield (i+y, j+x), (i+2*y, j+2*x)

    def generate_boards(self, size, symbol, symbol_amount):
        '''
        Generating board using Prim's algorithm
        :param size: size of the map, prefered odd number for
        :return: saved generated map to the global var
        '''
        self._symbol_amount = symbol_amount

        if size % 2 == 0:
            self.size_map = size+1  # preventing from 'double walled' borders
        else:
            self.size_map = size

        max_height = self.size_map

        max_width = int(float(size * 1.6))
        if max_width % 2 == 0:
            max_width += 1  # preventing from 'double walled' borders

        self.size_map_od = max_width  # updating global var
        # print(f'Size max szerokosc(od): {self.size_map_od}\nSize max wysokosc: {self.size_map}')  # debug output

        board = {}
        space_cells = set()
        connected_cells = set()
        walls_cells = set()

        # creating walls
        for j in range(0, max_height):
            for i in range(0, max_width):
                if (j == max_height - 1 and i >= 0) or (i == max_width - 1 and j >= 0) or i == 0 or i == max_width - 1 or j == 0 or j == max_height - 1:
                    board[(j, i)] = self.WALL

        board_length_rows = max_height - 1
        board_length_columns = max_width - 1

        # creating grid required for Prim's algorithm
        for j in range(1, board_length_rows):
            for i in range(1, board_length_columns):
                if (j % 2 == 0 and j != board_length_rows % 2) or (i % 2 == 0 and i != board_length_rows % 2):
                    board[(j, i)] = self.WALL
                else:
                    board[(j, i)] = self.EMPTY

        # checking each cell for EMPTY or a WALL and adding coordinates to separate set
        for i in range(1, board_length_rows):
            for j in range(1, board_length_columns):
                if board[(i, j)] == self.EMPTY:
                    space_cells.add((i, j))
                if board[(i, j)] == self.WALL:
                    walls_cells.add((i, j))

        connected_cells.add((1, 1))
        # using non-optimized Prim's algorithm to make maze
        while len(connected_cells) < len(space_cells):
            doA, doB = None, None
            cns = list(connected_cells)
            random.shuffle(cns)
            for (i, j) in cns:
                if doA is not None: break
                for A, B in self.neighbor_cell((i, j)):
                    if A not in walls_cells:
                        continue
                    if (B not in space_cells) or (B in connected_cells):
                        continue
                    doA, doB = A, B
                    break
            A, B = doA, doB
            board[A] = self.EMPTY
            walls_cells.remove(A)
            space_cells.add(A)
            connected_cells.add(A)
            connected_cells.add(B)

        self.add_item(symbol, symbol_amount, board)
        self.generated_map = board
        return board
        # saving generated map to variable

    def generate_string_map(self, read_map):
        '''
        Generating string map from dict
        :param read_map: passing dict map
        :return: string map
        '''
        lines = []
        for i in range(self.size_map):
            lines.append(''.join(read_map[(i, j)] for j in range(self.size_map_od)))
        self.generated_map_string = lines

    def print_map(self, read_map=None):
        '''
        Function prints map
        :param read_map: passing generated map (dict) if without param, the class map will be taken
        :return: printed map in string
        '''
        if read_map is None:
            read_map = self.generated_map
        self.generate_string_map(read_map)
        string_map = self.generated_map_string
        print('\n'.join(string_map))

    def add_item(self, symbol, amount, board):
        '''
        Function adds symbols to collect
        :param symbol: symbol generated on the board that will be collected
        :param amount: the number of the symbols generated on the board
        :param board: passed board
        :return: board with added symbols
        '''
        _board = board
        _symbol = symbol
        _amount = amount
        added_item = 0
        while added_item < _amount:
            y = random.randint(1, self.size_map_od-1)
            x = random.randint(1, self.size_map-1)
            if _board[(x, y)] == ' ' and ((x != 1 and y != 1) or (x != self.size_map_od-1 and y != self.size_map-1)):
                _board[(x, y)] = _symbol
                added_item += 1
        self.generated_map = _board

    @property
    def symbol_amount(self):
        return self._symbol_amount
